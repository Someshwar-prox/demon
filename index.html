<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Devil</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c, #1a1a1a);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            max-width: 900px;
            width: 100%;
            background: rgba(30, 30, 30, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
        }

        .header {
            text-align: center;
            margin-bottom: 10px;
        }

        .header h1 {
            font-size: 4em;
            background: linear-gradient(45deg, #ff0000, #ff6b00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            margin-bottom: 10px;
            font-weight: 900;
            letter-spacing: 2px;
        }

        .header .subtitle {
            font-size: 1.3em;
            color: #ccc;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            background: linear-gradient(135deg, #2d2d2d, #1f1f1f);
            padding: 15px 25px;
            border-radius: 15px;
            border: 1px solid #444;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
            font-size: 1.1em;
        }

        .stat {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: bold;
            color: #ffaa00;
            font-size: 1.8em;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        #gameCanvas {
            border: 3px solid #ff4444;
            border-radius: 15px;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.4);
            image-rendering: pixelated;
        }

        .controls {
            background: linear-gradient(135deg, #2d2d2d, #1f1f1f);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #444;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 100%;
        }

        .controls h3 {
            color: #ffaa00;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .keys-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .key {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .key-box {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #444, #222);
            border: 2px solid #666;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 0 #222;
            transition: all 0.1s;
        }

        .key-box.active {
            transform: translateY(4px);
            box-shadow: 0 0px 0 #222;
            background: linear-gradient(135deg, #ffaa00, #ff7700);
            color: #000;
        }

        .key-label {
            font-size: 0.9em;
            color: #aaa;
        }

        .level-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
        }

        .nav-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #444, #222);
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            transition: all 0.3s;
            min-width: 120px;
        }

        .nav-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #555, #333);
            transform: translateY(-2px);
        }

        .nav-btn:disabled {
            background: linear-gradient(135deg, #333, #111);
            color: #666;
            border-color: #444;
            cursor: not-allowed;
        }

        .level-select {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .level-btn {
            padding: 10px 5px;
            background: linear-gradient(135deg, #444, #222);
            border: 2px solid #555;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.3s;
            text-align: center;
        }

        .level-btn:hover:not(.locked) {
            background: linear-gradient(135deg, #555, #333);
            transform: translateY(-2px);
        }

        .level-btn:active {
            transform: translateY(2px);
        }

        .level-btn.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.7);
        }

        .level-btn.completed {
            background: linear-gradient(135deg, #44ff44, #00cc00);
            color: #000;
            border-color: #88ff88;
        }

        .level-btn.locked {
            background: linear-gradient(135deg, #333, #111);
            color: #666;
            border-color: #444;
            cursor: not-allowed;
            box-shadow: none;
        }

        .level-btn.locked:hover {
            transform: none;
            background: linear-gradient(135deg, #333, #111);
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff4444;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
            text-align: center;
            z-index: 100;
            display: none;
            min-width: 400px;
        }

        .message h2 {
            color: #ff4444;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .message p {
            margin: 15px 0;
            font-size: 1.3em;
            color: #ccc;
        }

        .message .stats {
            background: rgba(0, 0, 0, 0.3);
            margin: 20px 0;
            padding: 15px;
        }

        .message button {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 0 #990000;
        }

        .message button:hover {
            background: linear-gradient(135deg, #ff6666, #dd0000);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #990000;
        }

        .message button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #990000;
        }

        .death-animation {
            position: absolute;
            background: radial-gradient(circle, #ff4444, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: deathPulse 0.6s ease-out;
        }

        @keyframes deathPulse {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .instructions {
            background: linear-gradient(135deg, #2d2d2d, #1f1f1f);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
        }

        .page-info {
            color: #ffaa00;
            font-weight: bold;
            font-size: 1.1em;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 8px;
        }

        .difficulty-easy { background: #44ff44; color: #000; }
        .difficulty-medium { background: #ffaa00; color: #000; }
        .difficulty-hard { background: #ff4444; color: #fff; }
        .difficulty-expert { background: #aa00ff; color: #fff; }
        .difficulty-insane { background: #000; color: #fff; border: 1px solid #ff0000; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>LEVEL DEVIL</h1>
            <div class="subtitle">Smart Difficulty System - All Levels Working!</div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="currentLevel">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">DEATHS</div>
                <div class="stat-value" id="deathCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">TIME</div>
                <div class="stat-value" id="timer">0.0s</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div class="controls">
            <h3>CONTROLS</h3>
            <div class="keys-container">
                <div class="key">
                    <div class="key-box" id="leftKey">←</div>
                    <div class="key-label">LEFT</div>
                </div>
                <div class="key">
                    <div class="key-box" id="rightKey">→</div>
                    <div class="key-label">RIGHT</div>
                </div>
                <div class="key">
                    <div class="key-box" id="upKey">↑</div>
                    <div class="key-label">JUMP</div>
                </div>
            </div>
            
            <div class="level-nav">
                <button class="nav-btn" id="prevPage">◀ PREV</button>
                <span class="page-info">Pages: <span id="currentPage">1</span>/<span id="totalPages">1</span></span>
                <button class="nav-btn" id="nextPage">NEXT ▶</button>
            </div>

            <h3>SELECT LEVEL 
                <span class="difficulty-badge" id="difficultyBadge">EASY</span>
            </h3>
            <div class="level-select" id="levelGrid">
                <!-- Levels will be generated here -->
            </div>
            
            <div class="instructions">
                New Difficulty System: Platform Patterns, Enemy AI, and Special Mechanics!
            </div>
        </div>
    </div>

    <div class="message" id="levelComplete">
        <h2>LEVEL COMPLETE!</h2>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">DEATHS</div>
                <div class="stat-value" id="levelDeaths">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">TIME</div>
                <div class="stat-value" id="levelTime">0.0s</div>
            </div>
        </div>
        <button id="nextLevel">NEXT LEVEL</button>
    </div>

    <div class="message" id="gameComplete">
        <h2>CONGRATULATIONS!</h2>
        <p>You've beaten Level Devil!</p>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">TOTAL DEATHS</div>
                <div class="stat-value" id="totalDeaths">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">TOTAL TIME</div>
                <div class="stat-value" id="totalTime">0.0s</div>
            </div>
        </div>
        <button id="playAgain">PLAY AGAIN</button>
    </div>

    <script>
        class LevelDevil {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentLevel = 1;
                this.totalLevels = 50;
                this.deathCount = 0;
                this.startTime = Date.now();
                this.levelStartTime = Date.now();
                this.levelDeaths = 0;
                this.gameRunning = true;
                this.keys = {};
                this.completedLevels = new Set([1]);
                this.currentPage = 1;
                this.levelsPerPage = 20;
                
                this.player = {
                    x: 50,
                    y: 450,
                    width: 24,
                    height: 24,
                    velocityX: 0,
                    velocityY: 0,
                    speed: 6,
                    jumpPower: 14,
                    grounded: false,
                    color: '#ffaa00'
                };

                this.currentLevelData = this.generateLevel(1);
                
                this.setupEventListeners();
                this.generateLevelGrid();
                this.updateLevelButtons();
                this.updateDifficultyBadge();
                this.gameLoop();
                this.updateTimer();
            }

            getDifficultyTier(level) {
                if (level <= 10) return 'easy';
                if (level <= 20) return 'medium';
                if (level <= 30) return 'hard';
                if (level <= 40) return 'expert';
                return 'insane';
            }

            updateDifficultyBadge() {
                const badge = document.getElementById('difficultyBadge');
                const tier = this.getDifficultyTier(this.currentLevel);
                
                badge.textContent = tier.toUpperCase();
                badge.className = 'difficulty-badge difficulty-' + tier;
            }

            generateLevel(levelNumber) {
                const tier = this.getDifficultyTier(levelNumber);
                const level = {
                    platforms: [],
                    spikes: [],
                    enemies: [],
                    movingPlatforms: [],
                    disappearingPlatforms: [],
                    goal: { x: 750, y: 260, width: 30, height: 40 },
                    start: { x: 50, y: 450 }
                };

                // Always start with ground platform
                level.platforms.push({ x: 0, y: 480, width: 800, height: 20 });

                // Base parameters based on difficulty tier
                const params = {
                    easy: { platforms: 4, spikes: 2, gap: 120, platformWidth: 100 },
                    medium: { platforms: 6, spikes: 4, gap: 100, platformWidth: 80 },
                    hard: { platforms: 8, spikes: 6, gap: 80, platformWidth: 60 },
                    expert: { platforms: 10, spikes: 8, gap: 70, platformWidth: 50 },
                    insane: { platforms: 12, spikes: 10, gap: 60, platformWidth: 40 }
                }[tier];

                let lastX = 100;
                let lastY = 400;

                // Generate main path with different patterns based on tier
                for (let i = 0; i < params.platforms; i++) {
                    const heightVariation = {
                        easy: 50,
                        medium: 80,
                        hard: 120,
                        expert: 150,
                        insane: 200
                    }[tier];

                    const height = Math.max(300, Math.min(450, lastY + (Math.random() - 0.5) * heightVariation));
                    
                    level.platforms.push({
                        x: lastX,
                        y: height,
                        width: params.platformWidth,
                        height: 20
                    });

                    // Add spikes based on difficulty
                    if (i > 0 && Math.random() < 0.6) {
                        level.spikes.push({
                            x: lastX - 40,
                            y: 460,
                            width: 80,
                            height: 20
                        });
                    }

                    lastX += params.platformWidth + params.gap;
                    lastY = height;
                }

                // ADD SPECIAL MECHANICS BASED ON DIFFICULTY

                // Moving Platforms (Medium+)
                if (tier >= 'medium') {
                    const movingCount = tier === 'medium' ? 1 : tier === 'hard' ? 2 : 3;
                    for (let i = 0; i < movingCount; i++) {
                        const movingPlat = {
                            x: 200 + i * 180,
                            y: 350 - i * 40,
                            width: 80,
                            height: 15,
                            moving: true,
                            speed: 1 + (levelNumber * 0.05),
                            minX: 150 + i * 180,
                            maxX: 350 + i * 180,
                            direction: 1
                        };
                        level.platforms.push(movingPlat);
                        level.movingPlatforms.push(movingPlat);
                    }
                }

                // Disappearing Platforms (Hard+)
                if (tier >= 'hard') {
                    const disappearingCount = tier === 'hard' ? 1 : 2;
                    for (let i = 0; i < disappearingCount; i++) {
                        const disappearPlat = {
                            x: 300 + i * 200,
                            y: 320 - i * 50,
                            width: 60,
                            height: 15,
                            disappearing: true,
                            timer: 0,
                            visible: true,
                            cooldown: 120 // frames
                        };
                        level.platforms.push(disappearPlat);
                        level.disappearingPlatforms.push(disappearPlat);
                    }
                }

                // Enemy AI (Expert+)
                if (tier >= 'expert') {
                    const enemyCount = tier === 'expert' ? 1 : 2;
                    for (let i = 0; i < enemyCount; i++) {
                        level.enemies.push({
                            x: 250 + i * 250,
                            y: 430,
                            width: 20,
                            height: 20,
                            speed: 1 + (levelNumber * 0.02),
                            direction: 1,
                            patrolMin: 200 + i * 250,
                            patrolMax: 400 + i * 250
                        });
                    }
                }

                // Ceiling Spikes (Insane)
                if (tier === 'insane') {
                    for (let i = 0; i < 3; i++) {
                        level.spikes.push({
                            x: 150 + i * 200,
                            y: 50,
                            width: 100,
                            height: 20
                        });
                    }
                }

                // Position goal
                level.goal.x = lastX - 50;
                level.goal.y = lastY - 40;

                // Ensure goal is reachable
                if (level.goal.x > 750) level.goal.x = 750;
                if (level.goal.y < 100) level.goal.y = 100;

                return level;
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'a', 'd', 'w', ' '].includes(e.key)) {
                        this.keys[e.key] = true;
                        this.updateKeyDisplay();
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'a', 'd', 'w', ' '].includes(e.key)) {
                        this.keys[e.key] = false;
                        this.updateKeyDisplay();
                        e.preventDefault();
                    }
                });

                document.getElementById('nextLevel').addEventListener('click', () => {
                    this.nextLevel();
                });

                document.getElementById('playAgain').addEventListener('click', () => {
                    this.restartGame();
                });

                document.getElementById('prevPage').addEventListener('click', () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.generateLevelGrid();
                    }
                });

                document.getElementById('nextPage').addEventListener('click', () => {
                    const totalPages = Math.ceil(this.totalLevels / this.levelsPerPage);
                    if (this.currentPage < totalPages) {
                        this.currentPage++;
                        this.generateLevelGrid();
                    }
                });

                document.getElementById('levelGrid').addEventListener('click', (e) => {
                    if (e.target.classList.contains('level-btn')) {
                        const level = parseInt(e.target.dataset.level);
                        if (!e.target.classList.contains('locked')) {
                            this.loadLevel(level);
                        }
                    }
                });
            }

            generateLevelGrid() {
                const levelGrid = document.getElementById('levelGrid');
                levelGrid.innerHTML = '';
                
                const startLevel = (this.currentPage - 1) * this.levelsPerPage + 1;
                const endLevel = Math.min(this.currentPage * this.levelsPerPage, this.totalLevels);
                
                for (let i = startLevel; i <= endLevel; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.textContent = i;
                    btn.dataset.level = i;
                    
                    // Add difficulty color hint
                    const tier = this.getDifficultyTier(i);
                    btn.style.borderColor = {
                        easy: '#44ff44',
                        medium: '#ffaa00', 
                        hard: '#ff4444',
                        expert: '#aa00ff',
                        insane: '#ff0000'
                    }[tier];
                    
                    levelGrid.appendChild(btn);
                }
                
                this.updateLevelButtons();
                this.updatePageInfo();
            }

            updatePageInfo() {
                const totalPages = Math.ceil(this.totalLevels / this.levelsPerPage);
                document.getElementById('currentPage').textContent = this.currentPage;
                document.getElementById('totalPages').textContent = totalPages;
                
                document.getElementById('prevPage').disabled = this.currentPage === 1;
                document.getElementById('nextPage').disabled = this.currentPage === totalPages;
            }

            updateKeyDisplay() {
                const leftKey = document.getElementById('leftKey');
                const rightKey = document.getElementById('rightKey');
                const upKey = document.getElementById('upKey');

                leftKey.classList.toggle('active', this.keys['ArrowLeft'] || this.keys['a']);
                rightKey.classList.toggle('active', this.keys['ArrowRight'] || this.keys['d']);
                upKey.classList.toggle('active', this.keys['ArrowUp'] || this.keys['w'] || this.keys[' ']);
            }

            updateLevelButtons() {
                document.querySelectorAll('.level-btn').forEach(btn => {
                    const level = parseInt(btn.dataset.level);
                    
                    btn.classList.remove('active', 'completed', 'locked');
                    
                    if (level === this.currentLevel) {
                        btn.classList.add('active');
                    } else if (this.completedLevels.has(level)) {
                        btn.classList.add('completed');
                    } else if (level === 1 || this.completedLevels.has(level - 1)) {
                        // Level is unlocked but not completed
                    } else {
                        btn.classList.add('locked');
                    }
                });
            }

            loadLevel(level) {
                this.currentLevel = level;
                this.currentLevelData = this.generateLevel(level);
                this.player.x = this.currentLevelData.start.x;
                this.player.y = this.currentLevelData.start.y;
                this.player.velocityX = 0;
                this.player.velocityY = 0;
                this.levelStartTime = Date.now();
                this.levelDeaths = 0;
                this.gameRunning = true;

                document.getElementById('currentLevel').textContent = level;
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('gameComplete').style.display = 'none';

                this.updateLevelButtons();
                this.updateDifficultyBadge();
            }

            nextLevel() {
                this.completedLevels.add(this.currentLevel);
                if (this.currentLevel < this.totalLevels) {
                    this.completedLevels.add(this.currentLevel + 1);
                    this.loadLevel(this.currentLevel + 1);
                } else {
                    this.showGameComplete();
                }
            }

            showLevelComplete() {
                const levelTime = ((Date.now() - this.levelStartTime) / 1000).toFixed(1);
                document.getElementById('levelDeaths').textContent = this.levelDeaths;
                document.getElementById('levelTime').textContent = levelTime + 's';
                document.getElementById('levelComplete').style.display = 'block';
            }

            showGameComplete() {
                const totalTime = ((Date.now() - this.startTime) / 1000).toFixed(1);
                document.getElementById('totalDeaths').textContent = this.deathCount;
                document.getElementById('totalTime').textContent = totalTime + 's';
                document.getElementById('gameComplete').style.display = 'block';
            }

            restartGame() {
                this.currentLevel = 1;
                this.deathCount = 0;
                this.startTime = Date.now();
                this.completedLevels = new Set([1]);
                this.loadLevel(1);
                document.getElementById('deathCount').textContent = '0';
                this.generateLevelGrid();
            }

            updateTimer() {
                const currentTime = ((Date.now() - this.startTime) / 1000).toFixed(1);
                document.getElementById('timer').textContent = currentTime + 's';
                
                if (this.gameRunning) {
                    requestAnimationFrame(() => this.updateTimer());
                }
            }

            handleInput() {
                this.player.velocityX = 0;

                if (this.keys['ArrowLeft'] || this.keys['a']) {
                    this.player.velocityX = -this.player.speed;
                }
                if (this.keys['ArrowRight'] || this.keys['d']) {
                    this.player.velocityX = this.player.speed;
                }
                if ((this.keys['ArrowUp'] || this.keys['w'] || this.keys[' ']) && this.player.grounded) {
                    this.player.velocityY = -this.player.jumpPower;
                    this.player.grounded = false;
                }
            }

            updatePhysics() {
                // Update moving platforms
                this.currentLevelData.movingPlatforms.forEach(platform => {
                    platform.x += platform.speed * platform.direction;
                    if (platform.x >= platform.maxX || platform.x <= platform.minX) {
                        platform.direction *= -1;
                    }
                });

                // Update disappearing platforms
                this.currentLevelData.disappearingPlatforms.forEach(platform => {
                    platform.timer++;
                    if (platform.timer >= platform.cooldown) {
                        platform.visible = !platform.visible;
                        platform.timer = 0;
                    }
                });

                // Update enemies
                this.currentLevelData.enemies.forEach(enemy => {
                    enemy.x += enemy.speed * enemy.direction;
                    if (enemy.x >= enemy.patrolMax || enemy.x <= enemy.patrolMin) {
                        enemy.direction *= -1;
                    }

                    // Enemy collision
                    if (this.checkCollision(this.player, enemy)) {
                        this.die();
                    }
                });

                // Apply gravity
                this.player.velocityY += 0.5;

                // Update player position
                this.player.x += this.player.velocityX;
                this.player.y += this.player.velocityY;

                // Boundary checking
                if (this.player.x < 0) this.player.x = 0;
                if (this.player.x > this.canvas.width - this.player.width) {
                    this.player.x = this.canvas.width - this.player.width;
                }

                // Reset grounded state
                this.player.grounded = false;

                // Platform collisions
                this.currentLevelData.platforms.forEach(platform => {
                    // Skip invisible disappearing platforms
                    if (platform.disappearing && !platform.visible) return;
                    
                    if (this.checkCollision(this.player, platform)) {
                        // Coming from above - landing on platform
                        if (this.player.velocityY > 0 && this.player.y + this.player.height - this.player.velocityY <= platform.y) {
                            this.player.y = platform.y - this.player.height;
                            this.player.velocityY = 0;
                            this.player.grounded = true;
                        }
                        // Coming from below - hitting platform bottom
                        else if (this.player.velocityY < 0 && this.player.y - this.player.velocityY >= platform.y + platform.height) {
                            this.player.y = platform.y + platform.height;
                            this.player.velocityY = 0;
                        }
                        // Horizontal collision
                        else if (this.player.velocityX !== 0) {
                            if (this.player.x + this.player.width - this.player.velocityX <= platform.x) {
                                this.player.x = platform.x - this.player.width;
                            } else if (this.player.x - this.player.velocityX >= platform.x + platform.width) {
                                this.player.x = platform.x + platform.width;
                            }
                        }
                    }
                });

                // Spike collisions
                this.currentLevelData.spikes.forEach(spike => {
                    if (this.checkCollision(this.player, spike)) {
                        this.die();
                    }
                });

                // Goal collision
                if (this.checkCollision(this.player, this.currentLevelData.goal)) {
                    this.showLevelComplete();
                    this.gameRunning = false;
                }

                // Fall death
                if (this.player.y > this.canvas.height) {
                    this.die();
                }
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            die() {
                this.deathCount++;
                this.levelDeaths++;
                document.getElementById('deathCount').textContent = this.deathCount;
                
                // Create death animation
                const deathAnim = document.createElement('div');
                deathAnim.className = 'death-animation';
                deathAnim.style.left = (this.player.x + this.player.width/2 - 10) + 'px';
                deathAnim.style.top = (this.player.y + this.player.height/2 - 10) + 'px';
                deathAnim.style.width = '20px';
                deathAnim.style.height = '20px';
                document.body.appendChild(deathAnim);
                
                setTimeout(() => {
                    if (deathAnim.parentNode) {
                        document.body.removeChild(deathAnim);
                    }
                }, 600);

                // Reset player position
                this.player.x = this.currentLevelData.start.x;
                this.player.y = this.currentLevelData.start.y;
                this.player.velocityX = 0;
                this.player.velocityY = 0;
            }

            render() {
                // Clear canvas with gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#0a0a0a');
                gradient.addColorStop(1, '#1a1a1a');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw platforms
                this.currentLevelData.platforms.forEach(platform => {
                    // Skip invisible disappearing platforms
                    if (platform.disappearing && !platform.visible) return;
                    
                    // Platform shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(platform.x + 3, platform.y + 3, platform.width, platform.height);
                    
                    // Main platform with different colors for special types
                    let platGradient;
                    if (platform.moving) {
                        platGradient = this.ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                        platGradient.addColorStop(0, '#8888ff');
                        platGradient.addColorStop(1, '#4444aa');
                    } else if (platform.disappearing) {
                        const alpha = platform.visible ? 1 : 0.3;
                        platGradient = this.ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                        platGradient.addColorStop(0, `rgba(255, 255, 0, ${alpha})`);
                        platGradient.addColorStop(1, `rgba(200, 200, 0, ${alpha})`);
                    } else {
                        platGradient = this.ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                        platGradient.addColorStop(0, '#666');
                        platGradient.addColorStop(1, '#333');
                    }
                    this.ctx.fillStyle = platGradient;
                    this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Platform highlight
                    this.ctx.strokeStyle = platform.moving ? '#aaaaff' : platform.disappearing ? '#ffff00' : '#888';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                });

                // Draw spikes
                this.currentLevelData.spikes.forEach(spike => {
                    // Spike shadow
                    this.ctx.fillStyle = 'rgba(139, 0, 0, 0.5)';
                    this.ctx.fillRect(spike.x + 2, spike.y + 2, spike.width, spike.height);
                    
                    // Main spike
                    const spikeGradient = this.ctx.createLinearGradient(spike.x, spike.y, spike.x, spike.y + spike.height);
                    spikeGradient.addColorStop(0, '#ff4444');
                    spikeGradient.addColorStop(1, '#cc0000');
                    this.ctx.fillStyle = spikeGradient;
                    this.ctx.fillRect(spike.x, spike.y, spike.width, spike.height);
                    
                    // Draw individual spike triangles
                    this.ctx.fillStyle = '#990000';
                    const spikeCount = Math.floor(spike.width / 15);
                    for (let i = 0; i < spikeCount; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(spike.x + i * 15, spike.y + spike.height);
                        this.ctx.lineTo(spike.x + i * 15 + 7, spike.y);
                        this.ctx.lineTo(spike.x + i * 15 + 15, spike.y + spike.height);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                });

                // Draw enemies
                this.currentLevelData.enemies.forEach(enemy => {
                    // Enemy shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(enemy.x + 2, enemy.y + 2, enemy.width, enemy.height);
                    
                    // Main enemy
                    const enemyGradient = this.ctx.createLinearGradient(enemy.x, enemy.y, enemy.x, enemy.y + enemy.height);
                    enemyGradient.addColorStop(0, '#ff00ff');
                    enemyGradient.addColorStop(1, '#aa00aa');
                    this.ctx.fillStyle = enemyGradient;
                    this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    // Enemy eyes
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(enemy.x + 5, enemy.y + 5, 4, 4);
                    this.ctx.fillRect(enemy.x + 11, enemy.y + 5, 4, 4);
                });

                // Draw goal
                this.ctx.shadowColor = '#44ff44';
                this.ctx.shadowBlur = 15;
                const goalGradient = this.ctx.createLinearGradient(
                    this.currentLevelData.goal.x, this.currentLevelData.goal.y,
                    this.currentLevelData.goal.x, this.currentLevelData.goal.y + this.currentLevelData.goal.height
                );
                goalGradient.addColorStop(0, '#88ff88');
                goalGradient.addColorStop(1, '#00cc00');
                this.ctx.fillStyle = goalGradient;
                this.ctx.fillRect(this.currentLevelData.goal.x, this.currentLevelData.goal.y, 
                                this.currentLevelData.goal.width, this.currentLevelData.goal.height);
                this.ctx.shadowBlur = 0;

                // Draw player
                this.ctx.shadowColor = '#ffaa00';
                this.ctx.shadowBlur = 10;
                const playerGradient = this.ctx.createRadialGradient(
                    this.player.x + this.player.width/2, this.player.y + this.player.height/2, 0,
                    this.player.x + this.player.width/2, this.player.y + this.player.height/2, this.player.width/2
                );
                playerGradient.addColorStop(0, '#ffcc00');
                playerGradient.addColorStop(1, '#ff8800');
                this.ctx.fillStyle = playerGradient;
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                
                // Player details
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.player.x + 6, this.player.y + 6, 5, 5);
                this.ctx.fillRect(this.player.x + 13, this.player.y + 6, 5, 5);
                
                // Player mouth based on movement
                this.ctx.beginPath();
                if (this.player.velocityX > 0) {
                    this.ctx.arc(this.player.x + 18, this.player.y + 15, 3, 0, Math.PI * 2);
                } else if (this.player.velocityX < 0) {
                    this.ctx.arc(this.player.x + 6, this.player.y + 15, 3, 0, Math.PI * 2);
                } else {
                    this.ctx.rect(this.player.x + 8, this.player.y + 15, 8, 2);
                }
                this.ctx.fill();
            }

            gameLoop() {
                if (this.gameRunning) {
                    this.handleInput();
                    this.updatePhysics();
                }
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new LevelDevil();
        });
    </script>
</body>
</html>